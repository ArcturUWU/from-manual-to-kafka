{
  "name": "neo4j-postgres-sink",
  "config": {
    "connector.class": "streams.kafka.connect.sink.Neo4jSinkConnector",
    "tasks.max": "1",
    "topics": "postgres_server.public.department,postgres_server.public.specialty,postgres_server.public.course_of_lecture,postgres_server.public.lecture,postgres_server.public.st_group,postgres_server.public.students,postgres_server.public.schedule,postgres_server.public.attendance",
    "key.converter": "org.apache.kafka.connect.json.JsonConverter",
    "key.converter.schemas.enable": "false",
    "value.converter": "org.apache.kafka.connect.json.JsonConverter",
    "value.converter.schemas.enable": "false",
    "transforms": "unwrap",
    "transforms.unwrap.type": "io.debezium.transforms.ExtractNewRecordState",
    "transforms.unwrap.drop.tombstones": "false",
    "neo4j.server.uri": "bolt://neo4j:7687",
    "neo4j.authentication.basic.username": "neo4j",
    "neo4j.authentication.basic.password": "strongpassword",
    "errors.tolerance": "all",
    "errors.log.enable": "true",
    "errors.deadletterqueue.topic.name": "dlq.neo4j",
    "errors.deadletterqueue.context.headers.enable": "true",
    "errors.deadletterqueue.topic.replication.factor": "1",
    "neo4j.merge.allow.updates": "true",
    "neo4j.optimization.relationship.merge.strategy": "MERGE",
    "neo4j.connection.max.pool.size": "20",
    "neo4j.connection.liveness.check.timeout": "30000",
    "neo4j.topic.cypher.postgres_server.public.department": "MERGE (d:Department {postgres_id:event.id}) SET d.name=event.name",
    "neo4j.topic.cypher.postgres_server.public.specialty": "MATCH (d:Department {postgres_id:event.department_id}) MERGE (s:Specialty {postgres_id:event.id}) SET s.name=event.name MERGE (d)-[:HAS_SPECIALTY]->(s)",
    "neo4j.topic.cypher.postgres_server.public.st_group": "MATCH (s:Specialty {postgres_id:event.speciality_id}) MERGE (g:Group {postgres_id:event.id}) SET g.name=event.name MERGE (s)-[:HAS_GROUP]->(g)",
    "neo4j.topic.cypher.postgres_server.public.course_of_lecture": "MATCH (d:Department {postgres_id:event.department_id}),(s:Specialty {postgres_id:event.specialty_id}) MERGE (c:Course {postgres_id:event.id}) SET c.name=event.name MERGE (d)-[:OFFERS_COURSE]->(c) MERGE (s)-[:INCLUDES_COURSE]->(c)",
    "neo4j.topic.cypher.postgres_server.public.lecture": "MATCH (c:Course {postgres_id:event.course_of_lecture_id}) MERGE (l:Lecture {postgres_id:event.id}) SET l.name=event.name MERGE (c)-[:INCLUDES_LECTURE]->(l)",
    "neo4j.topic.cypher.postgres_server.public.students": "MATCH (g:Group {postgres_id:event.group_id}) MERGE (st:Student {postgres_id:event.id}) SET st.name=event.name,st.age=event.age,st.mail=event.mail MERGE (st)-[:MEMBER_OF]->(g)",
    "neo4j.topic.cypher.postgres_server.public.schedule": "MATCH (l:Lecture {postgres_id:event.lecture_id}), (g:Group {postgres_id:event.group_id}) MERGE (e:ScheduleEvent {postgres_id:event.id}) SET e.date = date(datetime({epochmillis: event.date / 1000})) MERGE (g)-[:SCHEDULED_FOR]->(e) MERGE (e)-[:OF_LECTURE]->(l)",
    "neo4j.topic.cypher.postgres_server.public.attendance": "MATCH (st:Student {postgres_id:event.student_id}),(e:ScheduleEvent {postgres_id:event.schedule_id}) MERGE (st)-[a:ATTENDED]->(e) SET a.attended=event.attended,a.updated=event.id"
  }
}